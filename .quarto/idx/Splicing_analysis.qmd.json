{"title":"Analysis of splicing variants using R","markdown":{"yaml":{"title":"Analysis of splicing variants using R","format":{"html":{"toc":true,"toc-depth":4,"code-fold":"show","code-link":true,"code-summary":"Show the code","page-layout":"full","fig-align":"center","fig-width":8,"fig-height":7,"embed-resources":true,"output-file":"Splicing Analysis Test report.htm","theme":{"dark":"superhero","light":"superhero"}}},"code-line-numbers":true,"execute":{"echo":"fenced","freeze":"auto"},"knitr":{"opts_chunk":{"collapse":true}},"editor":"visual"},"headingText":"Package Installations","headingAttr":{"id":"sec-package-installations","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\nThis section will install a lot of libraries required for general bioinformatics analysis in R.\n\n### Create a function to install multiple packages\n\n```{r}\n#ipak <- function(pkg){\n#    new.pkg <- pkg[!(pkg %in% installed.packages()[, \"Package\"])]\n#    if (length(new.pkg)) \n#        install.packages(new.pkg, dependencies = TRUE)\n#    sapply(pkg, require, character.only = TRUE)\n#}\n```\n\n```{r}\n#ipak(c(\"boot\", \"cluster\", \"codetools\", \"foreign\", \"KernSmooth\", \"lattice\", \"MASS\", \"Matrix\", \"\"))\n```\n\n```{r}\n#bio_pkgs <- c(\"ggbio\",\"biomaRt\", \"EnsDb.Hsapiens.v75\", \"renvcBioPortalData\", \n#          \"GenomicRanges\", \"GenomicFeatures\", \"TxDb.Hsapiens.UCSC.hg19.knownGene\", \"Homo.sapiens\", \"AnnotationDbi\", \"edgeR\", \"DESeq2\", \"FRASER\", \"SplicingGraphs\", \"SeqGSEA\", \"SpliceWiz\")\n#BiocManager::install(bio_pkgs)\n```\n\n------------------------------------------------------------------------\n\n## Analysis tutorial using FRASER\n\nThe idea here is to run the tutorial with the working example that is given in this \\[link\\](<https://colab.research.google.com/drive/1OKT32eNIq7Cz839jjqz-GJlvoToPYbib>). This will be then adjusted and run in a new notebook for the DMT1 analysis.\n\n```{r}\n# Add the directory where installed libs are stored\n.libPaths( c( .libPaths(), \"/home/ngadmin/development/R_libraries/\") )\n```\n\n```{r}\n# download required files \n#download.file(destfile=\"r-env-setup-script.R\", \n#    url=\"https://raw.githubusercontent.com/c-mertes/RNAseq-ASHG19/master/r-env-setup-script.R\")\n#source(\"r-env-setup-script.R\")\n#print(\"Setup done.\")\n```\n\n```{r}\nlibrary(OUTRIDER)\nlibrary(annotables)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(shiny)\nlibrary(tictoc)\n```\n\nUsing the raw read counts and a sample annnotation we can find the gene expression outliers\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nanno <- fread(\"./annotation.tsv\")[, 1:6]\ncts <- as.matrix(read.table(\"./outrider/raw_counts.tsv.gz\"))\n\n#sneak peak into the data\nhead(anno)\nprint(\"Dimensions of the annotation:\")\ndim(anno)\n\ncts[1:5, 1:10]\nprint(\"Dimensions of the count table:\")\ndim(cts)\n```\n\nCreate an Outrider object with the loaded annotation and raw count matrix\n\n```{r}\nanno[,sampleID:=INDIVIDUAL]\nods <- OutriderDataSet(countData = cts, colData = anno)\nods\n```\n\n### QC and preprocessing of raw count data.\n\n#### Size Factor\n\nIt represents the sequencing depth of each sample with respect to the others and is centered around 1. we can use `estimateSizeFactors` from DESeq2 and plot it.\n\nThings to consider:\n\n1.  A low *sizeFactor* could be an indication for a failed experiment or issues with RNA preperation\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nods <- estimateSizeFactors(ods)\nplotSizeFactors(ods)\n```\n\n##### Identify the sample with lowest *sizefactor*\n\n```{r}\nround(sort(sizeFactors(ods)), digits = 2)[1:5]\n```\n\n#### Filtering non-expressed genes\n\n-   It is done to reove genes that are not expressed or/and of low quality.\n\n-   to detect outliers removing non expressed genes gives a more robust result\n\n-   As a good starting point keep genes where at least 5% of the samples have FPKM value greater than 1 (FPKM: Fragments per kilobase of transcript per million mapped reads)\n\n```{r}\ntxdb <- loadDb(\"annotations/gencode.v29lift37.annotation.txdb\")\nods <- filterExpression(ods, gtfFile=txdb, filterGenes=FALSE)\n```\n\n-   Plot the number of genes filtered out and their expression distributions across sample/gene pairs\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nplotFPKM(ods) + theme(legend.position = 'bottom')\n```\n\n```{r}\n# filter object based on the expression status of the genes\nods <- ods[mcols(ods)[, \"passedFilter\"],]\nods\n```\n\n### Sample co-variation\n\n```{r}\noptions(repr.plot.height = 5, repr.plot.width = 6)\n\n# we will use normalize=FALSE since we have not corrected the data yet and cols from the #annotation to add labels to the heatmap\nplotCountCorHeatmap(ods, colGroups=c(\"SEX\", \"ORIGIN\"), rowGroups= \"LAB\", normalize= FALSE)\n```\n\n### Model Fitting {#sec-model-fitting}\n\nUsing OUTRIDER to model sample co-variation\n\n```{r}\ntic()\nregister(MulticoreParam(workers = 4, tasks = 12, progressbar = TRUE))\nods <- readRDS(\"outrider/fitted_ods.RDS\")\n#ods <- findEncodingDim(ods)\ngetBestQ(ods)\ntoc()\n#ods <- OUTRIDER(ods, q=getBestQ(ods))\n\n```\n\n```{r}\nplotEncDimSearch(ods)\n```\n\n```{r}\n# Check the heatmap\nplotCountCorHeatmap(ods, colGroups=c(\"SEX\", \"ORIGIN\"), rowGroups=\"LAB\", normalize=TRUE)\n```\n\n### Detection of Expression outliers {#sec-detection-of-expression-outliers}\n\nOutlier: An event that significantly deviates from the expected Negative-Bionomical distribution after controlling for confounders.\n\n```{r}\nplotAberrantPerSample(ods)\n```\n\n#### What are the genes that are outliers.\n\n```{r}\ngeneIDs <- gsub(\"\\\\.[0-9]*(_[0-9]*)?.*$\", \"\", rownames(ods))\nmap <- merge(data.table(ensgene=geneIDs), grch37, sort=FALSE, all.x=TRUE)[!duplicated(ensgene),]\n\n# Set new gene names only if hgnc symbol is present\nif(!\"ENSG\" %in% colnames(mcols(ods))){\n  mcols(ods)$ENSG <- geneIDs\n  rownames(ods) <- map[,ifelse(\n    is.na(symbol) | symbol == \"\" | duplicated(symbol), geneIDs, symbol)]\n}\n```\n\nLets retrivve the expression outliers\n\n```{r}\nres <- results(ods)\nhead(res)\ndim(res)\n```\n\n### Finding candidates in a patient.\n\nAs per the tutorial, sample NA18873 has a rare mitochondrial disease with complex 1 deficiency. This means we need to find MT genes abberently expressed.\n\n```{r}\nplotVolcano(ods, \"NA18873\", base=TRUE)\n```\n\n```{r}\nres[sampleID == \"NA18873\"]\n```\n\n```{r}\noptions(repr.plot.width=8, repr.plot.height=4)\n\nggarrange(ncol=2,\n    plotExpressionRank(ods, \"TIMMDC1\", norm=FALSE, basePlot=TRUE) + scale_y_log10(lim=c(300,2000)),\n    plotExpressionRank(ods, \"TIMMDC1\", norm=TRUE,  basePlot=TRUE) + scale_y_log10(lim=c(300,2000)))\n```\n\n# Aberrant Splicing Detection in RNA-Seq Data.\n\nA comprehensive background on Splicing and how FRASER works is available at <https://docs.google.com/presentation/d/1a7KZ6FXwVmGqF-FMAnz0QTk07WgzRWAbFhSNrUBspIQ/edit?pli=1#slide=id.g64b01c344e_4_394>\n\nHere we will focus on loading the packages and executing the tutorial.\n\n```{r}\nlibrary(FRASER)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(ggpubr)\nregister(SerialParam())\n```\n\n```{r}\nanno_fras <- fread(\"annotation.tsv\")[,1:6]\nanno_fras[, sampleID:=INDIVIDUAL]\njunctionCts <- fread(\"./splicing/raw_junction_counts.tsv.gz\")\nspliceSiteCts <- fread(\"./splicing/raw_site_counts.tsv.gz\")\n```\n\n```{r}\nhead(anno_fras)\njunctionCts[1:6, 1:15]\nspliceSiteCts[1:6, 1:15]\n```\n\n```{r}\n# Create a FRASER object\n\nfds <- FraserDataSet(colData = anno_fras, junctions = junctionCts, spliceSites = spliceSiteCts)\n\nfds\n```\n\nCreating a subset of data consisting 3 patients and 3 chromosomes only for splicing analysis\n\n```{r}\nset.seed(42)\npatient_ids <- c(\"NA11918\", \"NA20505\", \"HG00132\")\nfds <- fds <- fds[\n    seqnames(fds) %in% c(\"chr3\", \"chr6\", \"chr19\"),\n    unique(c(patient_ids, sample(colnames(fds))))[1:60]]\ndontWriteHDF5(fds) <- TRUE\nfds\n```\n\n### Filtering of data.\n\n1.  Calculate the splicing metric with Percent Spliced In (PSI) and Splicing efficiency.\n2.  Create filters such as min reads required per sample or the % of the samples having x reads at the least.\n3.  At least one sample has to have \\|Î”ðœ“\\|\\>0.1\n\n```{r}\nfds <- calculatePSIValues(fds)\nfds <- filterExpressionAndVariability(fds, minDeltaPsi = 0.1, filter = FALSE)\n```\n\n```{r}\noptions(repr.plot.width = 5, repr.plot.height = 4)\n\nplotFilterExpression(fds, bins=100)\nplotFilterVariability(fds) + theme(legend.position = \"none\")\n```\n\n```{r}\nfds <- fds[mcols(fds, type= \"j\")[,\"passed\"],]\nfds\n```\n\n-   have a look into our data to see if we do have correlation structure or not. To have a better estimate, we use the logit transformed ðœ“ values to compute the correlation. We can annotate our plot with any information provided through the sample annotation.\n\n```{r}\noptions(repr.plot.height = 5, repr.plot.width = 6)\n\nplotCountCorHeatmap(fds, type= \"psi5\", logit=TRUE, sampleClustering=NA, annotation_cols=c(\"SEX\", \"LAB\", \"ORIGIN\"))\n```\n\nHere I am training the model from scratch to see if this can be performed in the server\n\n```{r}\nregister(MulticoreParam(workers = 4, tasks = 20, progressbar = TRUE))\ntic(msg = \"Starting the loop\")\nfor(i in psiTypes) {\n  fds <- optimHyperParams(fds, i)\n  bestQ(fds,i)\n  plotEncDimSearch(fds, i)\n}\ntoc(log = TRUE)\n```\n\n```{r}\n#fds <- FRASER(fds) # uncommented because i have loaded fds from ./splicing/fitted_fds.RDS\nfds <- readRDS(\"splicing/fitted_fds.RDS\")\n```\n\n```{r}\nplotCountCorHeatmap(fds, type=\"psi5\", normalized=TRUE, logit=TRUE,\n                    topN=15000, annotation_col=c(\"SEX\", \"LAB\", \"ORIGIN\"), sampleClustering=NA)\n```\n\n```{r}\nplotAberrantPerSample(fds)\n```\n\n```{r}\nfds <- annotateRangesWithTxDb(fds)\n\nregister(SerialParam())\nres <- as.data.table(results(fds))\nres\n```\n\n```{r}\nresAsGR <- makeGRangesFromDataFrame(res, keep.extra.columns = TRUE)\n\n# group results by genes/sample\nresults_by_genes <- as.data.table(resultsByGenes(resAsGR))\nresults_by_genes\n```\n\n```{r}\noptions(repr.plot.width = 4, repr.plot.height = 4)\nplotVolcano(fds, type=\"psi5\", \"NA11918\")\n```\n\nIdentifying splicing events in detail\n\n```{r}\nres[sampleID == \"NA11918\"]\n```\n\n```{r}\nplotExpression(fds, type=\"psi5\", result=res[sampleID == \"NA11918\" & hgncSymbol == \"TIMMDC1\"][1])\n```\n\ndiagnosis, we want to make sure that our call is correct. Hence, we want to look at many metric to boost our confident into the call. Let's make a publication ready figure (except the sashimi plot\n\n```{r}\n# Make the plotting area t fit 4 panels\noptions(repr.plot.height = 4, repr.plot.width = 9)\n\nres2plot <- res[sampleID == \"NA11918\" & hgncSymbol == \"TIMMDC1\"][1,]\nggarrange(ncol = 2, \n          plotVolcano(fds, type= \"psi5\", \"NA11918\"),\n          plotExpression(fds, result = res2plot),\n          plotQQ(fds, result=res2plot),\n          plotExpectedVsObservedPsi(fds, result = res2plot))\n```\n\n## Mono Allelic expression\n\n```{r}\n#BiocManager::install(\"GenomicScores\")\n#remotes::install_github(\"gagneurlab/tMAE\")\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(tMAE)\n```\n\n```{r}\nallelicCountsFile <- 'https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/mae/allelic_counts.tsv.gz'\nallelicCounts <- fread(allelicCountsFile)\n\n# print data\nallelicCounts[1:4,]\ndim(allelicCounts)\n```\n\n```{r}\nprint('IDs in table')\nunique(allelicCounts$MAE_ID)\n```\n\nPlot counts of alternative vs reference allele.\n\n```{r}\nggplot(allelicCounts, aes(refCount+1, altCount+1)) + geom_point() + geom_abline(slope = 1, intercept = 0) + scale_y_log10() +scale_x_log10() + theme_bw()\n```\n\n### Run MAE test\n\n```{r}\nresMAE <- DESeq4MAE(allelicCounts, minCoverage = 10)\nhead(resMAE)\n```\n\n#### Determine the number of mono-allelic events\n\n```{r}\n# define significance of the event to be expressed as padj < 0.05\n\nresMAE[, signif := padj < 0.05]\n\n# get number of cases\nprint('MAE significant variants')\nresMAE[signif == TRUE, .N, by = MAE_ID]\n```\n\n```{r}\n# Add column for significant mono-allelic expression of the alternative\nresMAE[, signif_ALT := signif == TRUE & altRatio >= 0.8]\n\n# Get number of cases\nprint('MAE for the alternative significant variants')\nresMAE[signif_ALT == TRUE, .N, by = MAE_ID]\n```\n\n```{r}\n## If your data is based on assembly \n#BiocManager::install(\"MafDb.gnomAD.r2.1.hs37d5\") #comment out after install\nlibrary(MafDb.gnomAD.r2.1.hs37d5)\nmafdb <- MafDb.gnomAD.r2.1.hs37d5\n\n## If your data is based on assembly hg38\n#library(MafDb.gnomAD.r2.1.GRCh38)\n#mafdb <- MafDb.gnomAD.r2.1.GRCh38\n\n# convert results table into GRanges object\n#rng <- GRanges(seqnames = data$contig, \n#               ranges = IRanges(start = data$position, end = data$position), \n#               strand = '*')\n#resMAE$gnomadAF <- gscores(mafdb, rng)$AF\n\n```\n\n```{r}\n#Merge results with the annotation object\nresAnnot <- fread('https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/mae/mae_annotated_results.tsv.gz')\n\nresAnnot[, rare := (gnomadAF <= 0.01 | is.na(gnomadAF))]\nprint('Number of rare events in total (including non significant variants)')\nresAnnot[rare == TRUE, .N]\n```\n\nWhat are the rare mono-allelic events of these samples\n\n```{r}\nresAnnot[signif_ALT == TRUE & rare == TRUE]\n```\n\nVisualization using *plotAllelicCounts*\n\n```{r}\nsample1 <- 'HG00106'\nplotAllelicCounts(resAnnot[MAE_ID == sample1], rare_column = 'rare', title = sample1) + theme(legend.position = \"bottom\")\n  \n```\n\n```{r}\nsample2 <- 'HG00111'\nplotAllelicCounts(resAnnot[MAE_ID == sample2], rare_column = 'rare', title = sample2) + theme(legend.position = \"bottom\")\n```\n\n## Gene Prioritization\n\n```{r}\n\n# ensembleVEP requires variant_effect_predictor.pl in the PATH. For this you will likely have to manually install commandline version of https://www.ensembl.org/info/docs/tools/vep/script/vep_download.html\n# Also, the manuall install threw requirement of DBI as a perl package --> instal cpanminus using apt-get install followed by cpanm DBI\nlibrary(VariantAnnotation)\nlibrary(TVTB)\nlibrary(annotables)\nlibrary(ensemblVEP)\nlibrary(tidyverse)\nlibrary(data.table)\n```\n\n#### CASE 1\n\nThis boy was the third child of healthy non-consanguineous French parents. Pregnancy and delivery were uneventful. Early psychomotor development was normal. However, speech development was delayed, acquiring language at the age of 4. At 11, he began to experience psychomotor regression and progressive visual loss. At current (by the time of the publication) age of 47, he has severe walking difficulties, blindness, abnormal behaviour (easily frightened, sometimes aggressive) and spontaneous speech.\n\nIn our dataset, this sample is named **NA11918**.\n\n```{r}\n# Download a list of candidates\nresults_link=\"https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/outrider/results_pvalue.tsv.gz\"\noutrider_results_genes=fread(results_link)\n\n# Filter for the case of interest\noutrider_results_genes= outrider_results_genes %>% filter(sampleID==\"NA11918\") %>% select(geneID) %>% unlist\n\n# Take a look at what the gene list looks like\nhead(outrider_results_genes)\n# Get the number of candidate genes for that case\nprint(\"The total number of candidate genes within this case:\")\nlength(outrider_results_genes)\n```\n\nGeneIDs here are not totally in ENSEMBL format so we will have to convert to one\n\n```{r}\n# Modify gene format\noutrider_results_genes=str_extract(outrider_results_genes, \"ENSG[0-9]+\")\n\n# look at the changes\nhead(outrider_results_genes)\n```\n\nTo make it human readable gene names. we will use annotable package and filter them\n\n```{r}\ncandidate_genes=grch37 %>% filter(ensgene %in% outrider_results_genes)\n\n# look at the results\nhead(candidate_genes)\n```\n\nWe now have the list of candidate genes and more information on what they are. We are ready to filter this list to keep only the genes that are linked to the symptoms of the case of interest.\n\nIn our case, the symptoms are:\n\n-   Developmental regression ([HP:0002376](https://hpo.jax.org/app/browse/term/HP:0002376))\n\n-   Ataxia([HP:0001251](https://hpo.jax.org/app/browse/term/HP:0001251))\n\n-   Ophthalmoplegia ([HP:0000602](https://hpo.jax.org/app/browse/term/HP:0000602))\n\n-   Visual impairment ([HP:0000505](https://hpo.jax.org/app/browse/term/HP:0000505))\n\nAs you can see, there is an ID beside each symptom. Those are HPO term IDs, as found in the Human Phenotype Ontology [database](https://hpo.jax.org/app/).\n\n### Annotate candidate genes with HPO terms\n\n```{r}\nsample_HPO= c(\"HP:0002376\",\"HP:0001251\", \"HP:0000602\",\"HP:0000505\")\n\nsample_HPO\n```\n\n#### Load gene to HPO ID file from HPO database\n\nThe Human Phenotype Ontology gives access to a very useful file, showing the link between symptoms and genes. This file is updated regularly so we recommend to **download the latest version** whenever possible.\n\nYou can download this file [here](https://hpo.jax.org/app/data/annotations \"Link for downloading Genes to phenotype and other classifications of HPOA\").\n\n```{r}\n# Get the file URL https://hpo.jax.org/app/data/annotations. The file has to be manually downloaded\n\n\n# Read the file\ngene_hpo <-fread(\"./phenotype_to_genes.txt\", skip=1)\n\n# Select only the columns of interest (Gene and HPO term)\ngene_hpo <- gene_hpo[, c(4, 1)]\ncolnames(gene_hpo) <- c(\"Gene\", \"Term\")\n\n# Look at the results\nhead(gene_hpo)\n```\n\n#### Get a subset of genes that could match the syptoms\n\nNow that we have downloaded that file, we want to keep only the genes that are phenotypically relevant to the case.\n\n1.  Filter for HPO terms corresponding to the case\n\n2.  Obtain the Ensembl IDs for the genes that are associated to those HPO terms\n\n```{r}\ngenes_hpo_case=gene_hpo %>% \n  filter(Term %in% sample_HPO) %>%\n  left_join(grch37, by=c(\"Gene\"=\"symbol\"))\ngenes_hpo_case = genes_hpo_case %>% select(ensgene) %>% unique %>% unlist\n\nhead(genes_hpo_case)\nlength(genes_hpo_case)\n```\n\n#### Subset the list of genes to outlier candidates\n\nHere the assumption is that if there is an expression perturbation on the causal gene, this gene is somehow linked to some of the symptoms of the patient.\\\nSo we want to **filter** the list of genes somehow linked to the patients symptoms (listed in `genes_hpo_case`) for the one obtained as candidates in previous work.\n\n```{r}\n# Filter outlier genes for genes linked to the phenotype.\ncandidate_genes.hpo=candidate_genes %>% filter(ensgene %in% genes_hpo_case)\n\n# Get the number of genes left\ncat(\"The number of outlier genes left after filtering associated with the disease:\")\nlength(candidate_genes.hpo$ensgene)\n\n# Take a look at the results\ncandidate_genes.hpo\n```\n\n### Annotate with variant information\n\nWe can go further and annotate our candidate with the variant information for the case.\n\nTo do so, we need to transform the candidate gene list into the right format so that we can use the genes when reading in the [VCF](https://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/) file in R.\n\n#### Build a GRanges object with the genes obtain in previous steps\n\nWe use R packages that have been developped to handle and filter VCF files. Here, we want to upload only the part of the VCF file that is in regions of interest (i.e., our candidate genes). We can do this by giving as an input an object of type [GRanges](https://web.mit.edu/~r/current/arch/i386_linux26/lib/R/library/GenomicRanges/html/GRanges-class.html).\n\nThe next steps are transforming our list of candidate genes to the right format so that we can proceed with the analysis.\n\n1.  Change the start and end position to include potential regulatory regions (+/- 1kb here). Note that you can customize this distance or use the gene coordinates.\n\n```{r}\n# Extending the start/end coordinates to 1kb around the gene of interest \ncandidate_genes=candidate_genes.hpo %>% \n        mutate(new_start=pmin(start,end)-1e3, new_end=pmax(start,end)+1e3)\n\n# Take a look at the results\nhead(candidate_genes)\n```\n\n2.  Transform data frame into GRanges object\n\n```{r}\n# Create a GRanges Object\ncandidate_genes.gr=makeGRangesFromDataFrame(\n        candidate_genes, ignore.strand=TRUE,\n        start.field=\"new_start\",end.field=\"new_end\")\n\n# Add gene names to GRanges object\nnames(candidate_genes.gr)=candidate_genes$ensgene\n\ncandidate_genes.gr\n```\n\n#### Load a VCF file\n\n```{r}\nvcfFile <- \"./variants/1000G_subset_exome.vep.vcf.gz\"\n# index the VCF file\nindexVcf(vcfFile)\n\n# Create a reference\nvcfFile <- TabixFile(vcfFile)\n\nvcfFile\n```\n\n#### Read in the VCF file for the sample of interest\n\nFor demo purposes we can look at sample of interest and the overlapping genes of interest that consists or may consist the variants\n\n```{r}\nparams = ScanVcfParam(samples = \"NA11918\", which = candidate_genes.gr)\n\n# read the vcf file filter the data using the parameter file created above.\nvcf_rng <- readVcf(vcfFile, \"hg19\", params)\nhead(rowRanges(vcf_rng),3)\n```\n\n#### Filter for heterozygous or homozygous Alt and genes of interest\n\nIn genomics and sequencing, the term \"ALT\" typically refers to alternate contigs or alternate haplotypes. A contig is a contiguous sequence of DNA that has been assembled from fragments of sequenced DNA. Alternate contigs represent different versions of a particular region of the genome that may exist in a population or individual. Haplotypes are sets of alleles, or alternative forms of a gene, that are inherited together on a single chromosome. Alternate haplotypes represent different combinations of alleles that may exist in a population or individual.\n\n-   **ALT haplotypes in population genetics:** In population genetics, ALT haplotypes are used to study the genetic diversity of a population. By comparing the haplotypes of different individuals, researchers can identify common and rare variants and track the spread of mutations through a population.\n\n-   **ALT alleles in clinical genetics:** In clinical genetics, ALT alleles are used to identify individuals who may be at risk of genetic disorders. For example, some genetic disorders are caused by the presence of a particular combination of ALT alleles.\n\n```{r}\ncandidate_genes\n\n# Create a filter on variants hetero or homozyg alt\nHetfilt <- FilterRules(list(HetorHomAlt = \n        function(x) geno(x)$GT %in% c(\"0|1\", \"1|1\", \"1|0\")))\n\n# create a filter to keep only candidate gene annotations\nGeneFilt <- VcfVepRules(exprs = list(Cand_genes = \n        bquote(SYMBOL %in% .(candidate_genes$symbol) )))\n# Combine filters\ncombinedPreFilters <- VcfFilterRules(Hetfilt, GeneFilt)\n\n# apply them on the vcf\nvcf_het_cand <- subsetByFilter(vcf_rng, combinedPreFilters)\n\nrowRanges(vcf_het_cand)\n```\n\n#### Consequence field extraction\n\nIn order to see potential features we can filter on lets grab the consequence field of the VCF.\n\n```{r}\n# Parse the consequence field of the VCF\ncsq <- parseCSQToGRanges(x=vcf_het_cand, VCFRowID = rownames(vcf_het_cand))\ncsq[, c(\"Consequence\", \"SYMBOL\", \"BIOTYPE\", \"gnomAD_AF\", \"CADD_PHRED\")]\n```\n\n#### Define a set of filters\n\nYou can custom create a set of filters that you want to apply on your data. These can be Transcription Start Site (TSS), allele frequency, CADD score, Variant Effect Prediction consequences and so forth.\n\n``` html\n<span style=\"color:red\"> \nAlex What sort of filters would be ideal for NewGenia's Pipeline? \n</span>\n```\n\n```{r}\n# Filter on distance to the gene\nvepDistFilter <- VcfVepRules(exprs=list(Distance=expression(DISTANCE <= 1000)))\n\n# Filter on allele frequency\n# Here we allow NAs because some variants are uniq to the individual and hence\n# not listed in any public database (eg. gnomAD)\nvepMAFFilter<- VcfVepRules(exprs = list(MAF = \n        expression(as.numeric(gnomAD_AF) <= 0.01 || gnomAD_AF == \"NA\")))\n\n# Filter on CADD score\nvepCADDFilter <- VcfVepRules(exprs = list(CADD=expression(CADD_PHRED >= 20)))\n\n# Filter on consequences\nhighImpactVariant<-VcfVepRules(exprs=list(BigImpact=\n        expression(grepl(x=Consequence, pattern=paste(collapse=\"|\", c(\n                \"splice_acceptor_variant\", \"splice_donor_variant\", \n                \"stop_gained\", \"stop_lost\",\"frameshift_variant\"))))))\n\nregulatoryVariant<-VcfVepRules(exprs=list(RegVar=\n        expression(grepl(x=Consequence, pattern=paste(collapse=\"|\", c(\n                \"5_prime_UTR_variant\", \"3_prime_UTR_variant\", \"intron_variant\",\n                \"NMD_transcript_variant\", \"upstream_gene_variant\", \n                \"downstream_gene_variant\"))))))\n\ncombinedFilters <- VcfFilterRules(\n  vepDistFilter,\n  vepMAFFilter,\n  vepCADDFilter, \n  highImpactVariant,\n  regulatoryVariant)\n```\n\n```{r}\nactive(combinedFilters)\n```\n\n```{r}\nactive(combinedFilters)[\"BigImpact\"] <- FALSE\nactive(combinedFilters)[\"RegVar\"] <- FALSE\nactive(combinedFilters)[\"Distance\"] <- FALSE\nactive(combinedFilters)[\"CADD\"] <- FALSE\n\nactive(combinedFilters)[\"MAF\"] <- TRUE\n\nactive(combinedFilters)\n```\n\n```{r}\n# subset VCF with active filters\nvcf_filt <- subsetByFilter(vcf_het_cand, combinedFilters)\n\ncsq_filt <- ensemblVEP::parseCSQToGRanges(x = vcf_filt)\n\nunique(csq_filt[,c(\"Consequence\", \"SYMBOL\", \"BIOTYPE\", \"gnomAD_AF\",\"CADD_PHRED\")])\n```\n\n```{r}\n# Look at number of variants left for each set of filters\nsummary(evalSeparately(expr=combinedFilters, envir=vcf_het_cand))\n\n```\n","srcMarkdownNoYaml":"\n\n## Package Installations {#sec-package-installations}\n\nThis section will install a lot of libraries required for general bioinformatics analysis in R.\n\n### Create a function to install multiple packages\n\n```{r}\n#ipak <- function(pkg){\n#    new.pkg <- pkg[!(pkg %in% installed.packages()[, \"Package\"])]\n#    if (length(new.pkg)) \n#        install.packages(new.pkg, dependencies = TRUE)\n#    sapply(pkg, require, character.only = TRUE)\n#}\n```\n\n```{r}\n#ipak(c(\"boot\", \"cluster\", \"codetools\", \"foreign\", \"KernSmooth\", \"lattice\", \"MASS\", \"Matrix\", \"\"))\n```\n\n```{r}\n#bio_pkgs <- c(\"ggbio\",\"biomaRt\", \"EnsDb.Hsapiens.v75\", \"renvcBioPortalData\", \n#          \"GenomicRanges\", \"GenomicFeatures\", \"TxDb.Hsapiens.UCSC.hg19.knownGene\", \"Homo.sapiens\", \"AnnotationDbi\", \"edgeR\", \"DESeq2\", \"FRASER\", \"SplicingGraphs\", \"SeqGSEA\", \"SpliceWiz\")\n#BiocManager::install(bio_pkgs)\n```\n\n------------------------------------------------------------------------\n\n## Analysis tutorial using FRASER\n\nThe idea here is to run the tutorial with the working example that is given in this \\[link\\](<https://colab.research.google.com/drive/1OKT32eNIq7Cz839jjqz-GJlvoToPYbib>). This will be then adjusted and run in a new notebook for the DMT1 analysis.\n\n```{r}\n# Add the directory where installed libs are stored\n.libPaths( c( .libPaths(), \"/home/ngadmin/development/R_libraries/\") )\n```\n\n```{r}\n# download required files \n#download.file(destfile=\"r-env-setup-script.R\", \n#    url=\"https://raw.githubusercontent.com/c-mertes/RNAseq-ASHG19/master/r-env-setup-script.R\")\n#source(\"r-env-setup-script.R\")\n#print(\"Setup done.\")\n```\n\n```{r}\nlibrary(OUTRIDER)\nlibrary(annotables)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(shiny)\nlibrary(tictoc)\n```\n\nUsing the raw read counts and a sample annnotation we can find the gene expression outliers\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nanno <- fread(\"./annotation.tsv\")[, 1:6]\ncts <- as.matrix(read.table(\"./outrider/raw_counts.tsv.gz\"))\n\n#sneak peak into the data\nhead(anno)\nprint(\"Dimensions of the annotation:\")\ndim(anno)\n\ncts[1:5, 1:10]\nprint(\"Dimensions of the count table:\")\ndim(cts)\n```\n\nCreate an Outrider object with the loaded annotation and raw count matrix\n\n```{r}\nanno[,sampleID:=INDIVIDUAL]\nods <- OutriderDataSet(countData = cts, colData = anno)\nods\n```\n\n### QC and preprocessing of raw count data.\n\n#### Size Factor\n\nIt represents the sequencing depth of each sample with respect to the others and is centered around 1. we can use `estimateSizeFactors` from DESeq2 and plot it.\n\nThings to consider:\n\n1.  A low *sizeFactor* could be an indication for a failed experiment or issues with RNA preperation\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nods <- estimateSizeFactors(ods)\nplotSizeFactors(ods)\n```\n\n##### Identify the sample with lowest *sizefactor*\n\n```{r}\nround(sort(sizeFactors(ods)), digits = 2)[1:5]\n```\n\n#### Filtering non-expressed genes\n\n-   It is done to reove genes that are not expressed or/and of low quality.\n\n-   to detect outliers removing non expressed genes gives a more robust result\n\n-   As a good starting point keep genes where at least 5% of the samples have FPKM value greater than 1 (FPKM: Fragments per kilobase of transcript per million mapped reads)\n\n```{r}\ntxdb <- loadDb(\"annotations/gencode.v29lift37.annotation.txdb\")\nods <- filterExpression(ods, gtfFile=txdb, filterGenes=FALSE)\n```\n\n-   Plot the number of genes filtered out and their expression distributions across sample/gene pairs\n\n```{r}\n#| column: screen-inset\n#| layout-nrow: 1\nplotFPKM(ods) + theme(legend.position = 'bottom')\n```\n\n```{r}\n# filter object based on the expression status of the genes\nods <- ods[mcols(ods)[, \"passedFilter\"],]\nods\n```\n\n### Sample co-variation\n\n```{r}\noptions(repr.plot.height = 5, repr.plot.width = 6)\n\n# we will use normalize=FALSE since we have not corrected the data yet and cols from the #annotation to add labels to the heatmap\nplotCountCorHeatmap(ods, colGroups=c(\"SEX\", \"ORIGIN\"), rowGroups= \"LAB\", normalize= FALSE)\n```\n\n### Model Fitting {#sec-model-fitting}\n\nUsing OUTRIDER to model sample co-variation\n\n```{r}\ntic()\nregister(MulticoreParam(workers = 4, tasks = 12, progressbar = TRUE))\nods <- readRDS(\"outrider/fitted_ods.RDS\")\n#ods <- findEncodingDim(ods)\ngetBestQ(ods)\ntoc()\n#ods <- OUTRIDER(ods, q=getBestQ(ods))\n\n```\n\n```{r}\nplotEncDimSearch(ods)\n```\n\n```{r}\n# Check the heatmap\nplotCountCorHeatmap(ods, colGroups=c(\"SEX\", \"ORIGIN\"), rowGroups=\"LAB\", normalize=TRUE)\n```\n\n### Detection of Expression outliers {#sec-detection-of-expression-outliers}\n\nOutlier: An event that significantly deviates from the expected Negative-Bionomical distribution after controlling for confounders.\n\n```{r}\nplotAberrantPerSample(ods)\n```\n\n#### What are the genes that are outliers.\n\n```{r}\ngeneIDs <- gsub(\"\\\\.[0-9]*(_[0-9]*)?.*$\", \"\", rownames(ods))\nmap <- merge(data.table(ensgene=geneIDs), grch37, sort=FALSE, all.x=TRUE)[!duplicated(ensgene),]\n\n# Set new gene names only if hgnc symbol is present\nif(!\"ENSG\" %in% colnames(mcols(ods))){\n  mcols(ods)$ENSG <- geneIDs\n  rownames(ods) <- map[,ifelse(\n    is.na(symbol) | symbol == \"\" | duplicated(symbol), geneIDs, symbol)]\n}\n```\n\nLets retrivve the expression outliers\n\n```{r}\nres <- results(ods)\nhead(res)\ndim(res)\n```\n\n### Finding candidates in a patient.\n\nAs per the tutorial, sample NA18873 has a rare mitochondrial disease with complex 1 deficiency. This means we need to find MT genes abberently expressed.\n\n```{r}\nplotVolcano(ods, \"NA18873\", base=TRUE)\n```\n\n```{r}\nres[sampleID == \"NA18873\"]\n```\n\n```{r}\noptions(repr.plot.width=8, repr.plot.height=4)\n\nggarrange(ncol=2,\n    plotExpressionRank(ods, \"TIMMDC1\", norm=FALSE, basePlot=TRUE) + scale_y_log10(lim=c(300,2000)),\n    plotExpressionRank(ods, \"TIMMDC1\", norm=TRUE,  basePlot=TRUE) + scale_y_log10(lim=c(300,2000)))\n```\n\n# Aberrant Splicing Detection in RNA-Seq Data.\n\nA comprehensive background on Splicing and how FRASER works is available at <https://docs.google.com/presentation/d/1a7KZ6FXwVmGqF-FMAnz0QTk07WgzRWAbFhSNrUBspIQ/edit?pli=1#slide=id.g64b01c344e_4_394>\n\nHere we will focus on loading the packages and executing the tutorial.\n\n```{r}\nlibrary(FRASER)\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(ggpubr)\nregister(SerialParam())\n```\n\n```{r}\nanno_fras <- fread(\"annotation.tsv\")[,1:6]\nanno_fras[, sampleID:=INDIVIDUAL]\njunctionCts <- fread(\"./splicing/raw_junction_counts.tsv.gz\")\nspliceSiteCts <- fread(\"./splicing/raw_site_counts.tsv.gz\")\n```\n\n```{r}\nhead(anno_fras)\njunctionCts[1:6, 1:15]\nspliceSiteCts[1:6, 1:15]\n```\n\n```{r}\n# Create a FRASER object\n\nfds <- FraserDataSet(colData = anno_fras, junctions = junctionCts, spliceSites = spliceSiteCts)\n\nfds\n```\n\nCreating a subset of data consisting 3 patients and 3 chromosomes only for splicing analysis\n\n```{r}\nset.seed(42)\npatient_ids <- c(\"NA11918\", \"NA20505\", \"HG00132\")\nfds <- fds <- fds[\n    seqnames(fds) %in% c(\"chr3\", \"chr6\", \"chr19\"),\n    unique(c(patient_ids, sample(colnames(fds))))[1:60]]\ndontWriteHDF5(fds) <- TRUE\nfds\n```\n\n### Filtering of data.\n\n1.  Calculate the splicing metric with Percent Spliced In (PSI) and Splicing efficiency.\n2.  Create filters such as min reads required per sample or the % of the samples having x reads at the least.\n3.  At least one sample has to have \\|Î”ðœ“\\|\\>0.1\n\n```{r}\nfds <- calculatePSIValues(fds)\nfds <- filterExpressionAndVariability(fds, minDeltaPsi = 0.1, filter = FALSE)\n```\n\n```{r}\noptions(repr.plot.width = 5, repr.plot.height = 4)\n\nplotFilterExpression(fds, bins=100)\nplotFilterVariability(fds) + theme(legend.position = \"none\")\n```\n\n```{r}\nfds <- fds[mcols(fds, type= \"j\")[,\"passed\"],]\nfds\n```\n\n-   have a look into our data to see if we do have correlation structure or not. To have a better estimate, we use the logit transformed ðœ“ values to compute the correlation. We can annotate our plot with any information provided through the sample annotation.\n\n```{r}\noptions(repr.plot.height = 5, repr.plot.width = 6)\n\nplotCountCorHeatmap(fds, type= \"psi5\", logit=TRUE, sampleClustering=NA, annotation_cols=c(\"SEX\", \"LAB\", \"ORIGIN\"))\n```\n\nHere I am training the model from scratch to see if this can be performed in the server\n\n```{r}\nregister(MulticoreParam(workers = 4, tasks = 20, progressbar = TRUE))\ntic(msg = \"Starting the loop\")\nfor(i in psiTypes) {\n  fds <- optimHyperParams(fds, i)\n  bestQ(fds,i)\n  plotEncDimSearch(fds, i)\n}\ntoc(log = TRUE)\n```\n\n```{r}\n#fds <- FRASER(fds) # uncommented because i have loaded fds from ./splicing/fitted_fds.RDS\nfds <- readRDS(\"splicing/fitted_fds.RDS\")\n```\n\n```{r}\nplotCountCorHeatmap(fds, type=\"psi5\", normalized=TRUE, logit=TRUE,\n                    topN=15000, annotation_col=c(\"SEX\", \"LAB\", \"ORIGIN\"), sampleClustering=NA)\n```\n\n```{r}\nplotAberrantPerSample(fds)\n```\n\n```{r}\nfds <- annotateRangesWithTxDb(fds)\n\nregister(SerialParam())\nres <- as.data.table(results(fds))\nres\n```\n\n```{r}\nresAsGR <- makeGRangesFromDataFrame(res, keep.extra.columns = TRUE)\n\n# group results by genes/sample\nresults_by_genes <- as.data.table(resultsByGenes(resAsGR))\nresults_by_genes\n```\n\n```{r}\noptions(repr.plot.width = 4, repr.plot.height = 4)\nplotVolcano(fds, type=\"psi5\", \"NA11918\")\n```\n\nIdentifying splicing events in detail\n\n```{r}\nres[sampleID == \"NA11918\"]\n```\n\n```{r}\nplotExpression(fds, type=\"psi5\", result=res[sampleID == \"NA11918\" & hgncSymbol == \"TIMMDC1\"][1])\n```\n\ndiagnosis, we want to make sure that our call is correct. Hence, we want to look at many metric to boost our confident into the call. Let's make a publication ready figure (except the sashimi plot\n\n```{r}\n# Make the plotting area t fit 4 panels\noptions(repr.plot.height = 4, repr.plot.width = 9)\n\nres2plot <- res[sampleID == \"NA11918\" & hgncSymbol == \"TIMMDC1\"][1,]\nggarrange(ncol = 2, \n          plotVolcano(fds, type= \"psi5\", \"NA11918\"),\n          plotExpression(fds, result = res2plot),\n          plotQQ(fds, result=res2plot),\n          plotExpectedVsObservedPsi(fds, result = res2plot))\n```\n\n## Mono Allelic expression\n\n```{r}\n#BiocManager::install(\"GenomicScores\")\n#remotes::install_github(\"gagneurlab/tMAE\")\n```\n\n```{r}\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(tMAE)\n```\n\n```{r}\nallelicCountsFile <- 'https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/mae/allelic_counts.tsv.gz'\nallelicCounts <- fread(allelicCountsFile)\n\n# print data\nallelicCounts[1:4,]\ndim(allelicCounts)\n```\n\n```{r}\nprint('IDs in table')\nunique(allelicCounts$MAE_ID)\n```\n\nPlot counts of alternative vs reference allele.\n\n```{r}\nggplot(allelicCounts, aes(refCount+1, altCount+1)) + geom_point() + geom_abline(slope = 1, intercept = 0) + scale_y_log10() +scale_x_log10() + theme_bw()\n```\n\n### Run MAE test\n\n```{r}\nresMAE <- DESeq4MAE(allelicCounts, minCoverage = 10)\nhead(resMAE)\n```\n\n#### Determine the number of mono-allelic events\n\n```{r}\n# define significance of the event to be expressed as padj < 0.05\n\nresMAE[, signif := padj < 0.05]\n\n# get number of cases\nprint('MAE significant variants')\nresMAE[signif == TRUE, .N, by = MAE_ID]\n```\n\n```{r}\n# Add column for significant mono-allelic expression of the alternative\nresMAE[, signif_ALT := signif == TRUE & altRatio >= 0.8]\n\n# Get number of cases\nprint('MAE for the alternative significant variants')\nresMAE[signif_ALT == TRUE, .N, by = MAE_ID]\n```\n\n```{r}\n## If your data is based on assembly \n#BiocManager::install(\"MafDb.gnomAD.r2.1.hs37d5\") #comment out after install\nlibrary(MafDb.gnomAD.r2.1.hs37d5)\nmafdb <- MafDb.gnomAD.r2.1.hs37d5\n\n## If your data is based on assembly hg38\n#library(MafDb.gnomAD.r2.1.GRCh38)\n#mafdb <- MafDb.gnomAD.r2.1.GRCh38\n\n# convert results table into GRanges object\n#rng <- GRanges(seqnames = data$contig, \n#               ranges = IRanges(start = data$position, end = data$position), \n#               strand = '*')\n#resMAE$gnomadAF <- gscores(mafdb, rng)$AF\n\n```\n\n```{r}\n#Merge results with the annotation object\nresAnnot <- fread('https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/mae/mae_annotated_results.tsv.gz')\n\nresAnnot[, rare := (gnomadAF <= 0.01 | is.na(gnomadAF))]\nprint('Number of rare events in total (including non significant variants)')\nresAnnot[rare == TRUE, .N]\n```\n\nWhat are the rare mono-allelic events of these samples\n\n```{r}\nresAnnot[signif_ALT == TRUE & rare == TRUE]\n```\n\nVisualization using *plotAllelicCounts*\n\n```{r}\nsample1 <- 'HG00106'\nplotAllelicCounts(resAnnot[MAE_ID == sample1], rare_column = 'rare', title = sample1) + theme(legend.position = \"bottom\")\n  \n```\n\n```{r}\nsample2 <- 'HG00111'\nplotAllelicCounts(resAnnot[MAE_ID == sample2], rare_column = 'rare', title = sample2) + theme(legend.position = \"bottom\")\n```\n\n## Gene Prioritization\n\n```{r}\n\n# ensembleVEP requires variant_effect_predictor.pl in the PATH. For this you will likely have to manually install commandline version of https://www.ensembl.org/info/docs/tools/vep/script/vep_download.html\n# Also, the manuall install threw requirement of DBI as a perl package --> instal cpanminus using apt-get install followed by cpanm DBI\nlibrary(VariantAnnotation)\nlibrary(TVTB)\nlibrary(annotables)\nlibrary(ensemblVEP)\nlibrary(tidyverse)\nlibrary(data.table)\n```\n\n#### CASE 1\n\nThis boy was the third child of healthy non-consanguineous French parents. Pregnancy and delivery were uneventful. Early psychomotor development was normal. However, speech development was delayed, acquiring language at the age of 4. At 11, he began to experience psychomotor regression and progressive visual loss. At current (by the time of the publication) age of 47, he has severe walking difficulties, blindness, abnormal behaviour (easily frightened, sometimes aggressive) and spontaneous speech.\n\nIn our dataset, this sample is named **NA11918**.\n\n```{r}\n# Download a list of candidates\nresults_link=\"https://i12g-gagneurweb.in.tum.de/public/workshops/RNAseq_ASHG19/input_data/outrider/results_pvalue.tsv.gz\"\noutrider_results_genes=fread(results_link)\n\n# Filter for the case of interest\noutrider_results_genes= outrider_results_genes %>% filter(sampleID==\"NA11918\") %>% select(geneID) %>% unlist\n\n# Take a look at what the gene list looks like\nhead(outrider_results_genes)\n# Get the number of candidate genes for that case\nprint(\"The total number of candidate genes within this case:\")\nlength(outrider_results_genes)\n```\n\nGeneIDs here are not totally in ENSEMBL format so we will have to convert to one\n\n```{r}\n# Modify gene format\noutrider_results_genes=str_extract(outrider_results_genes, \"ENSG[0-9]+\")\n\n# look at the changes\nhead(outrider_results_genes)\n```\n\nTo make it human readable gene names. we will use annotable package and filter them\n\n```{r}\ncandidate_genes=grch37 %>% filter(ensgene %in% outrider_results_genes)\n\n# look at the results\nhead(candidate_genes)\n```\n\nWe now have the list of candidate genes and more information on what they are. We are ready to filter this list to keep only the genes that are linked to the symptoms of the case of interest.\n\nIn our case, the symptoms are:\n\n-   Developmental regression ([HP:0002376](https://hpo.jax.org/app/browse/term/HP:0002376))\n\n-   Ataxia([HP:0001251](https://hpo.jax.org/app/browse/term/HP:0001251))\n\n-   Ophthalmoplegia ([HP:0000602](https://hpo.jax.org/app/browse/term/HP:0000602))\n\n-   Visual impairment ([HP:0000505](https://hpo.jax.org/app/browse/term/HP:0000505))\n\nAs you can see, there is an ID beside each symptom. Those are HPO term IDs, as found in the Human Phenotype Ontology [database](https://hpo.jax.org/app/).\n\n### Annotate candidate genes with HPO terms\n\n```{r}\nsample_HPO= c(\"HP:0002376\",\"HP:0001251\", \"HP:0000602\",\"HP:0000505\")\n\nsample_HPO\n```\n\n#### Load gene to HPO ID file from HPO database\n\nThe Human Phenotype Ontology gives access to a very useful file, showing the link between symptoms and genes. This file is updated regularly so we recommend to **download the latest version** whenever possible.\n\nYou can download this file [here](https://hpo.jax.org/app/data/annotations \"Link for downloading Genes to phenotype and other classifications of HPOA\").\n\n```{r}\n# Get the file URL https://hpo.jax.org/app/data/annotations. The file has to be manually downloaded\n\n\n# Read the file\ngene_hpo <-fread(\"./phenotype_to_genes.txt\", skip=1)\n\n# Select only the columns of interest (Gene and HPO term)\ngene_hpo <- gene_hpo[, c(4, 1)]\ncolnames(gene_hpo) <- c(\"Gene\", \"Term\")\n\n# Look at the results\nhead(gene_hpo)\n```\n\n#### Get a subset of genes that could match the syptoms\n\nNow that we have downloaded that file, we want to keep only the genes that are phenotypically relevant to the case.\n\n1.  Filter for HPO terms corresponding to the case\n\n2.  Obtain the Ensembl IDs for the genes that are associated to those HPO terms\n\n```{r}\ngenes_hpo_case=gene_hpo %>% \n  filter(Term %in% sample_HPO) %>%\n  left_join(grch37, by=c(\"Gene\"=\"symbol\"))\ngenes_hpo_case = genes_hpo_case %>% select(ensgene) %>% unique %>% unlist\n\nhead(genes_hpo_case)\nlength(genes_hpo_case)\n```\n\n#### Subset the list of genes to outlier candidates\n\nHere the assumption is that if there is an expression perturbation on the causal gene, this gene is somehow linked to some of the symptoms of the patient.\\\nSo we want to **filter** the list of genes somehow linked to the patients symptoms (listed in `genes_hpo_case`) for the one obtained as candidates in previous work.\n\n```{r}\n# Filter outlier genes for genes linked to the phenotype.\ncandidate_genes.hpo=candidate_genes %>% filter(ensgene %in% genes_hpo_case)\n\n# Get the number of genes left\ncat(\"The number of outlier genes left after filtering associated with the disease:\")\nlength(candidate_genes.hpo$ensgene)\n\n# Take a look at the results\ncandidate_genes.hpo\n```\n\n### Annotate with variant information\n\nWe can go further and annotate our candidate with the variant information for the case.\n\nTo do so, we need to transform the candidate gene list into the right format so that we can use the genes when reading in the [VCF](https://www.internationalgenome.org/wiki/Analysis/Variant%20Call%20Format/vcf-variant-call-format-version-40/) file in R.\n\n#### Build a GRanges object with the genes obtain in previous steps\n\nWe use R packages that have been developped to handle and filter VCF files. Here, we want to upload only the part of the VCF file that is in regions of interest (i.e., our candidate genes). We can do this by giving as an input an object of type [GRanges](https://web.mit.edu/~r/current/arch/i386_linux26/lib/R/library/GenomicRanges/html/GRanges-class.html).\n\nThe next steps are transforming our list of candidate genes to the right format so that we can proceed with the analysis.\n\n1.  Change the start and end position to include potential regulatory regions (+/- 1kb here). Note that you can customize this distance or use the gene coordinates.\n\n```{r}\n# Extending the start/end coordinates to 1kb around the gene of interest \ncandidate_genes=candidate_genes.hpo %>% \n        mutate(new_start=pmin(start,end)-1e3, new_end=pmax(start,end)+1e3)\n\n# Take a look at the results\nhead(candidate_genes)\n```\n\n2.  Transform data frame into GRanges object\n\n```{r}\n# Create a GRanges Object\ncandidate_genes.gr=makeGRangesFromDataFrame(\n        candidate_genes, ignore.strand=TRUE,\n        start.field=\"new_start\",end.field=\"new_end\")\n\n# Add gene names to GRanges object\nnames(candidate_genes.gr)=candidate_genes$ensgene\n\ncandidate_genes.gr\n```\n\n#### Load a VCF file\n\n```{r}\nvcfFile <- \"./variants/1000G_subset_exome.vep.vcf.gz\"\n# index the VCF file\nindexVcf(vcfFile)\n\n# Create a reference\nvcfFile <- TabixFile(vcfFile)\n\nvcfFile\n```\n\n#### Read in the VCF file for the sample of interest\n\nFor demo purposes we can look at sample of interest and the overlapping genes of interest that consists or may consist the variants\n\n```{r}\nparams = ScanVcfParam(samples = \"NA11918\", which = candidate_genes.gr)\n\n# read the vcf file filter the data using the parameter file created above.\nvcf_rng <- readVcf(vcfFile, \"hg19\", params)\nhead(rowRanges(vcf_rng),3)\n```\n\n#### Filter for heterozygous or homozygous Alt and genes of interest\n\nIn genomics and sequencing, the term \"ALT\" typically refers to alternate contigs or alternate haplotypes. A contig is a contiguous sequence of DNA that has been assembled from fragments of sequenced DNA. Alternate contigs represent different versions of a particular region of the genome that may exist in a population or individual. Haplotypes are sets of alleles, or alternative forms of a gene, that are inherited together on a single chromosome. Alternate haplotypes represent different combinations of alleles that may exist in a population or individual.\n\n-   **ALT haplotypes in population genetics:** In population genetics, ALT haplotypes are used to study the genetic diversity of a population. By comparing the haplotypes of different individuals, researchers can identify common and rare variants and track the spread of mutations through a population.\n\n-   **ALT alleles in clinical genetics:** In clinical genetics, ALT alleles are used to identify individuals who may be at risk of genetic disorders. For example, some genetic disorders are caused by the presence of a particular combination of ALT alleles.\n\n```{r}\ncandidate_genes\n\n# Create a filter on variants hetero or homozyg alt\nHetfilt <- FilterRules(list(HetorHomAlt = \n        function(x) geno(x)$GT %in% c(\"0|1\", \"1|1\", \"1|0\")))\n\n# create a filter to keep only candidate gene annotations\nGeneFilt <- VcfVepRules(exprs = list(Cand_genes = \n        bquote(SYMBOL %in% .(candidate_genes$symbol) )))\n# Combine filters\ncombinedPreFilters <- VcfFilterRules(Hetfilt, GeneFilt)\n\n# apply them on the vcf\nvcf_het_cand <- subsetByFilter(vcf_rng, combinedPreFilters)\n\nrowRanges(vcf_het_cand)\n```\n\n#### Consequence field extraction\n\nIn order to see potential features we can filter on lets grab the consequence field of the VCF.\n\n```{r}\n# Parse the consequence field of the VCF\ncsq <- parseCSQToGRanges(x=vcf_het_cand, VCFRowID = rownames(vcf_het_cand))\ncsq[, c(\"Consequence\", \"SYMBOL\", \"BIOTYPE\", \"gnomAD_AF\", \"CADD_PHRED\")]\n```\n\n#### Define a set of filters\n\nYou can custom create a set of filters that you want to apply on your data. These can be Transcription Start Site (TSS), allele frequency, CADD score, Variant Effect Prediction consequences and so forth.\n\n``` html\n<span style=\"color:red\"> \nAlex What sort of filters would be ideal for NewGenia's Pipeline? \n</span>\n```\n\n```{r}\n# Filter on distance to the gene\nvepDistFilter <- VcfVepRules(exprs=list(Distance=expression(DISTANCE <= 1000)))\n\n# Filter on allele frequency\n# Here we allow NAs because some variants are uniq to the individual and hence\n# not listed in any public database (eg. gnomAD)\nvepMAFFilter<- VcfVepRules(exprs = list(MAF = \n        expression(as.numeric(gnomAD_AF) <= 0.01 || gnomAD_AF == \"NA\")))\n\n# Filter on CADD score\nvepCADDFilter <- VcfVepRules(exprs = list(CADD=expression(CADD_PHRED >= 20)))\n\n# Filter on consequences\nhighImpactVariant<-VcfVepRules(exprs=list(BigImpact=\n        expression(grepl(x=Consequence, pattern=paste(collapse=\"|\", c(\n                \"splice_acceptor_variant\", \"splice_donor_variant\", \n                \"stop_gained\", \"stop_lost\",\"frameshift_variant\"))))))\n\nregulatoryVariant<-VcfVepRules(exprs=list(RegVar=\n        expression(grepl(x=Consequence, pattern=paste(collapse=\"|\", c(\n                \"5_prime_UTR_variant\", \"3_prime_UTR_variant\", \"intron_variant\",\n                \"NMD_transcript_variant\", \"upstream_gene_variant\", \n                \"downstream_gene_variant\"))))))\n\ncombinedFilters <- VcfFilterRules(\n  vepDistFilter,\n  vepMAFFilter,\n  vepCADDFilter, \n  highImpactVariant,\n  regulatoryVariant)\n```\n\n```{r}\nactive(combinedFilters)\n```\n\n```{r}\nactive(combinedFilters)[\"BigImpact\"] <- FALSE\nactive(combinedFilters)[\"RegVar\"] <- FALSE\nactive(combinedFilters)[\"Distance\"] <- FALSE\nactive(combinedFilters)[\"CADD\"] <- FALSE\n\nactive(combinedFilters)[\"MAF\"] <- TRUE\n\nactive(combinedFilters)\n```\n\n```{r}\n# subset VCF with active filters\nvcf_filt <- subsetByFilter(vcf_het_cand, combinedFilters)\n\ncsq_filt <- ensemblVEP::parseCSQToGRanges(x = vcf_filt)\n\nunique(csq_filt[,c(\"Consequence\", \"SYMBOL\", \"BIOTYPE\", \"gnomAD_AF\",\"CADD_PHRED\")])\n```\n\n```{r}\n# Look at number of variants left for each set of filters\nsummary(evalSeparately(expr=combinedFilters, envir=vcf_het_cand))\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":8,"fig-height":7,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":"fenced","output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":true,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":4,"embed-resources":true,"output-file":"Splicing Analysis Test report.htm"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","editor":"visual","title":"Analysis of splicing variants using R","knitr":{"opts_chunk":{"collapse":true}},"code-summary":"Show the code","page-layout":"full"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}